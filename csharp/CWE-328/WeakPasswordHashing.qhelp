<!DOCTYPE qhelp PUBLIC
        "-//Semmle//qhelp//EN"
        "qhelp.dtd">
<qhelp>
    <overview>
        <p>
            Using a an inappropriate hash function can leave data
            vulnerable, and should not be used for password hashing.
        </p>

        <p>
            A strong cryptographic hash function should be resistant to:
        </p>
        <ul>
            <li>
                <strong>Pre-image attacks</strong>. If you know a hash value <code>h(x)</code>,
                you should not be able to easily find the input <code>x</code>.
            </li>
            <li>
                <strong>Collision attacks</strong>. If you know a hash value <code>h(x)</code>,
                you should not be able to easily find a different input
                <code>y</code>
                with the same hash value <code>h(x) = h(y)</code>.
            </li>
            <li>
                <strong>Brute force</strong>. If you know a hash value <code>h(x)</code>,
                you should not be able to quickly find an input <code>y</code> that computes to that hash value
                using brute force attacks.
            <li>
        </ul>

        <p>
            All of MD5, SHA-1, SHA-2 and SHA-3 are weak against offline brute forcing.
        </p>

        <p>
            Password hashing algorithms are designed to be slow to compute, which makes brute force attacks more difficult.
        </p>

    </overview>
    <recommendation>

        <p>
            Ensure that you use a strong, password-appropriate cryptographic hash function, such as:
        </p>

        <ul>
            <li>
                Argon2, scrypt, bcrypt, or PBKDF2 for passwords and other data with limited input space where
                a dictionary-like attack is feasible.
            </li>
        </ul>

    </recommendation>
    <example>

        <p>
            The following examples show a function for checking whether the hash
            of content (not a certificate or password) matches a known value -- to prevent tampering.

            In the first case the SHA-512 hashing algorithm is used that is known to be vulnerable to brute force attacks and side-channel attacks.
        </p>
        <sample src="WeakPasswordHashingBad.csharp"/>
        <p>

            Here is the same function using SHA-512, which is a strong cryptographic hashing function suitable for tamper detection (but <em>not</em> for certificate integrity <em>nor</em> password hashing).
        </p>
        <sample src="WeakSensitiveDataHashingGood.csharp"/>

    </example>
    <references>
        <li>
            OWASP:
            <a href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html">Password Storage
                Cheat Sheet
            </a>
            and
            <a href="https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html#use-strong-cryptographic-hashing-algorithms">
                Transport Layer Protection Cheat Sheet
            </a>
        </li>
    </references>

</qhelp>
